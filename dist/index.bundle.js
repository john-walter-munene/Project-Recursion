/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("// import { format } from \"date-fns\";\r\n// import _ from 'lodash';\r\nconsole.log(\"Template works.\")\r\n\r\n// First working solution for iterative fibonnaci.\r\nfunction fibonacciIterative(number) {\r\n    const myArray = [0, 1];\r\n\r\n    while(myArray.length < number) {\r\n\r\n        let lastElement = myArray[myArray.length - 1];\r\n        let secondLastElement = myArray[myArray.length - 2];\r\n\r\n        let sumOfLastTwoElements = secondLastElement + lastElement;\r\n        myArray.push(sumOfLastTwoElements);\r\n    };\r\n\r\n    return myArray;\r\n}\r\n// Above code works, but for every iteration I check my arrays length\r\n// More overhead\r\n// console.log(fibonacciIterative(8)); // [0, 1, 1, 2, 3, 5, 8, 13]\r\n\r\n// Optimized solution.\r\nfunction fibonacciIterativeTwo(number) {\r\n\r\n    if (number <= 0) return [];\r\n    if (number === 1) return [0];\r\n    if (number === 2) return [0, 1];\r\n\r\n    const myArray = [0, 1];\r\n\r\n    // Iterate up to less two elements as they are predefined.\r\n    for (let counter = 0; counter < number - 2; counter++) {\r\n        let lastElement = myArray[myArray.length - 1];\r\n        let secondLastElement = myArray[myArray.length - 2];\r\n\r\n        let sumOfLastTwoElements = secondLastElement + lastElement;\r\n        myArray.push(sumOfLastTwoElements);\r\n    }\r\n\r\n    return myArray;\r\n}\r\n\r\n// console.log(fibonacciIterativeTwo(8)); // [0, 1, 1, 2, 3, 5, 8, 13]\r\n\r\nfunction fibRec(number) {\r\n    if (number <= 0) return [];          // Return an empty array for non-positive numbers\r\n    if (number === 1) return [0];        // Base case for 1 element\r\n    if (number === 2) return [0, 1];     // Base case for 2 elements\r\n\r\n    const myArray = fibRec(number - 1);\r\n    return [...myArray, myArray[myArray.length - 1] + myArray[myArray.length - 2]];\r\n}\r\n\r\nconsole.log(fibRec(8)); // [0, 1, 1, 2, 3, 5, 8, 13]\r\n\r\n// Best solution...\r\nfunction fibRecTwo(numbers, fibArray = [0, 1]) {\r\n    if (fibArray.length > numbers) { \r\n        return fibArray.slice(0, numbers);\r\n    }\r\n    \r\n    // Add the next Fibonacci number to the array\r\n    fibArray.push(fibArray[fibArray.length - 1] + fibArray[fibArray.length - 2]);\r\n    \r\n    // Recursively call fibRecTwo with the updated fibArray\r\n    return fibRecTwo(numbers, fibArray);\r\n}\r\n\r\nconsole.log(fibRecTwo(8)); // [0, 1, 1, 2, 3, 5, 8, 13, 21]\r\n\r\nfunction mergeSort(array, low = 0, high = array.length - 1) {\r\n    if (low < high) {\r\n\r\n        // Find middle point.\r\n        let middle = Math.floor((low + high) / 2);\r\n\r\n        // Recursive sort both halves.\r\n        mergeSort(array, low, middle);\r\n        mergeSort(array, middle + 1, high);\r\n\r\n        // Create copies of the subarrays\r\n        let leftArray = array.slice(low, middle + 1);\r\n        let rightArray = array.slice(middle + 1, high + 1);\r\n\r\n        // Merge the arrays\r\n        let i = 0, j = 0, k = low;\r\n        while (i < leftArray.length && j < rightArray.length) {\r\n            if (leftArray[i] <= rightArray[j]) {\r\n                array[k++] = leftArray[i++];\r\n            } else {\r\n                array[k++] = rightArray[j++];\r\n            }\r\n        }\r\n\r\n        // Copy remaining elements of leftArray, if any\r\n        while (i < leftArray.length) {\r\n            array[k++] = leftArray[i++];\r\n        }\r\n\r\n         // Copy remaining elements of rightArray, if any\r\n        while (j < rightArray.length) {\r\n            array[k++] = rightArray[j++];\r\n        }\r\n    }\r\n\r\n    return array;\r\n}\r\n\r\nconsole.log(mergeSort([100, 3, 2, 1, 13, 8, 5, 0, 1, 98]));\r\n\r\n// Alternative solution.\r\nfunction alternativeMergeSort(array) {\r\n    if (array.length < 2) return array; // Base case\r\n\r\n    let middlePoint = Math.floor(array.length / 2);\r\n    let leftArray = array.slice(0, middlePoint);\r\n    let rightArray = array.slice(middlePoint, array.length);\r\n\r\n    return actualMerger(alternativeMergeSort(leftArray), alternativeMergeSort(rightArray));\r\n}\r\n\r\nfunction actualMerger(left, right) {\r\n    const result = [];\r\n    let i = 0, j = 0;\r\n\r\n    // Merge the two sorted arrays\r\n    while (i < left.length && j < right.length) {\r\n        if (left[i] <= right[j]) {\r\n            result.push(left[i++]);\r\n        } else {\r\n            result.push(right[j++]);\r\n        }\r\n    }\r\n\r\n    // Add remaining elements from left array\r\n    while (i < left.length) {\r\n        result.push(left[i++]);\r\n    }\r\n\r\n    // Add remaining elements from right array\r\n    while (j < right.length) {\r\n        result.push(right[j++]);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nconsole.log(alternativeMergeSort([100, 3, 2, 1, 13, 8, 5, 0, 1, 98]));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RldnN0YXJ0YnVpbGRpbmcvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgeyBmb3JtYXQgfSBmcm9tIFwiZGF0ZS1mbnNcIjtcclxuLy8gaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcclxuY29uc29sZS5sb2coXCJUZW1wbGF0ZSB3b3Jrcy5cIilcclxuXHJcbi8vIEZpcnN0IHdvcmtpbmcgc29sdXRpb24gZm9yIGl0ZXJhdGl2ZSBmaWJvbm5hY2kuXHJcbmZ1bmN0aW9uIGZpYm9uYWNjaUl0ZXJhdGl2ZShudW1iZXIpIHtcclxuICAgIGNvbnN0IG15QXJyYXkgPSBbMCwgMV07XHJcblxyXG4gICAgd2hpbGUobXlBcnJheS5sZW5ndGggPCBudW1iZXIpIHtcclxuXHJcbiAgICAgICAgbGV0IGxhc3RFbGVtZW50ID0gbXlBcnJheVtteUFycmF5Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGxldCBzZWNvbmRMYXN0RWxlbWVudCA9IG15QXJyYXlbbXlBcnJheS5sZW5ndGggLSAyXTtcclxuXHJcbiAgICAgICAgbGV0IHN1bU9mTGFzdFR3b0VsZW1lbnRzID0gc2Vjb25kTGFzdEVsZW1lbnQgKyBsYXN0RWxlbWVudDtcclxuICAgICAgICBteUFycmF5LnB1c2goc3VtT2ZMYXN0VHdvRWxlbWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gbXlBcnJheTtcclxufVxyXG4vLyBBYm92ZSBjb2RlIHdvcmtzLCBidXQgZm9yIGV2ZXJ5IGl0ZXJhdGlvbiBJIGNoZWNrIG15IGFycmF5cyBsZW5ndGhcclxuLy8gTW9yZSBvdmVyaGVhZFxyXG4vLyBjb25zb2xlLmxvZyhmaWJvbmFjY2lJdGVyYXRpdmUoOCkpOyAvLyBbMCwgMSwgMSwgMiwgMywgNSwgOCwgMTNdXHJcblxyXG4vLyBPcHRpbWl6ZWQgc29sdXRpb24uXHJcbmZ1bmN0aW9uIGZpYm9uYWNjaUl0ZXJhdGl2ZVR3byhudW1iZXIpIHtcclxuXHJcbiAgICBpZiAobnVtYmVyIDw9IDApIHJldHVybiBbXTtcclxuICAgIGlmIChudW1iZXIgPT09IDEpIHJldHVybiBbMF07XHJcbiAgICBpZiAobnVtYmVyID09PSAyKSByZXR1cm4gWzAsIDFdO1xyXG5cclxuICAgIGNvbnN0IG15QXJyYXkgPSBbMCwgMV07XHJcblxyXG4gICAgLy8gSXRlcmF0ZSB1cCB0byBsZXNzIHR3byBlbGVtZW50cyBhcyB0aGV5IGFyZSBwcmVkZWZpbmVkLlxyXG4gICAgZm9yIChsZXQgY291bnRlciA9IDA7IGNvdW50ZXIgPCBudW1iZXIgLSAyOyBjb3VudGVyKyspIHtcclxuICAgICAgICBsZXQgbGFzdEVsZW1lbnQgPSBteUFycmF5W215QXJyYXkubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgbGV0IHNlY29uZExhc3RFbGVtZW50ID0gbXlBcnJheVtteUFycmF5Lmxlbmd0aCAtIDJdO1xyXG5cclxuICAgICAgICBsZXQgc3VtT2ZMYXN0VHdvRWxlbWVudHMgPSBzZWNvbmRMYXN0RWxlbWVudCArIGxhc3RFbGVtZW50O1xyXG4gICAgICAgIG15QXJyYXkucHVzaChzdW1PZkxhc3RUd29FbGVtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG15QXJyYXk7XHJcbn1cclxuXHJcbi8vIGNvbnNvbGUubG9nKGZpYm9uYWNjaUl0ZXJhdGl2ZVR3byg4KSk7IC8vIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxM11cclxuXHJcbmZ1bmN0aW9uIGZpYlJlYyhudW1iZXIpIHtcclxuICAgIGlmIChudW1iZXIgPD0gMCkgcmV0dXJuIFtdOyAgICAgICAgICAvLyBSZXR1cm4gYW4gZW1wdHkgYXJyYXkgZm9yIG5vbi1wb3NpdGl2ZSBudW1iZXJzXHJcbiAgICBpZiAobnVtYmVyID09PSAxKSByZXR1cm4gWzBdOyAgICAgICAgLy8gQmFzZSBjYXNlIGZvciAxIGVsZW1lbnRcclxuICAgIGlmIChudW1iZXIgPT09IDIpIHJldHVybiBbMCwgMV07ICAgICAvLyBCYXNlIGNhc2UgZm9yIDIgZWxlbWVudHNcclxuXHJcbiAgICBjb25zdCBteUFycmF5ID0gZmliUmVjKG51bWJlciAtIDEpO1xyXG4gICAgcmV0dXJuIFsuLi5teUFycmF5LCBteUFycmF5W215QXJyYXkubGVuZ3RoIC0gMV0gKyBteUFycmF5W215QXJyYXkubGVuZ3RoIC0gMl1dO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhmaWJSZWMoOCkpOyAvLyBbMCwgMSwgMSwgMiwgMywgNSwgOCwgMTNdXHJcblxyXG4vLyBCZXN0IHNvbHV0aW9uLi4uXHJcbmZ1bmN0aW9uIGZpYlJlY1R3byhudW1iZXJzLCBmaWJBcnJheSA9IFswLCAxXSkge1xyXG4gICAgaWYgKGZpYkFycmF5Lmxlbmd0aCA+IG51bWJlcnMpIHsgXHJcbiAgICAgICAgcmV0dXJuIGZpYkFycmF5LnNsaWNlKDAsIG51bWJlcnMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBZGQgdGhlIG5leHQgRmlib25hY2NpIG51bWJlciB0byB0aGUgYXJyYXlcclxuICAgIGZpYkFycmF5LnB1c2goZmliQXJyYXlbZmliQXJyYXkubGVuZ3RoIC0gMV0gKyBmaWJBcnJheVtmaWJBcnJheS5sZW5ndGggLSAyXSk7XHJcbiAgICBcclxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNhbGwgZmliUmVjVHdvIHdpdGggdGhlIHVwZGF0ZWQgZmliQXJyYXlcclxuICAgIHJldHVybiBmaWJSZWNUd28obnVtYmVycywgZmliQXJyYXkpO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhmaWJSZWNUd28oOCkpOyAvLyBbMCwgMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxXVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VTb3J0KGFycmF5LCBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoIC0gMSkge1xyXG4gICAgaWYgKGxvdyA8IGhpZ2gpIHtcclxuXHJcbiAgICAgICAgLy8gRmluZCBtaWRkbGUgcG9pbnQuXHJcbiAgICAgICAgbGV0IG1pZGRsZSA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XHJcblxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZSBzb3J0IGJvdGggaGFsdmVzLlxyXG4gICAgICAgIG1lcmdlU29ydChhcnJheSwgbG93LCBtaWRkbGUpO1xyXG4gICAgICAgIG1lcmdlU29ydChhcnJheSwgbWlkZGxlICsgMSwgaGlnaCk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBjb3BpZXMgb2YgdGhlIHN1YmFycmF5c1xyXG4gICAgICAgIGxldCBsZWZ0QXJyYXkgPSBhcnJheS5zbGljZShsb3csIG1pZGRsZSArIDEpO1xyXG4gICAgICAgIGxldCByaWdodEFycmF5ID0gYXJyYXkuc2xpY2UobWlkZGxlICsgMSwgaGlnaCArIDEpO1xyXG5cclxuICAgICAgICAvLyBNZXJnZSB0aGUgYXJyYXlzXHJcbiAgICAgICAgbGV0IGkgPSAwLCBqID0gMCwgayA9IGxvdztcclxuICAgICAgICB3aGlsZSAoaSA8IGxlZnRBcnJheS5sZW5ndGggJiYgaiA8IHJpZ2h0QXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0QXJyYXlbaV0gPD0gcmlnaHRBcnJheVtqXSkge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbaysrXSA9IGxlZnRBcnJheVtpKytdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbaysrXSA9IHJpZ2h0QXJyYXlbaisrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29weSByZW1haW5pbmcgZWxlbWVudHMgb2YgbGVmdEFycmF5LCBpZiBhbnlcclxuICAgICAgICB3aGlsZSAoaSA8IGxlZnRBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXJyYXlbaysrXSA9IGxlZnRBcnJheVtpKytdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIENvcHkgcmVtYWluaW5nIGVsZW1lbnRzIG9mIHJpZ2h0QXJyYXksIGlmIGFueVxyXG4gICAgICAgIHdoaWxlIChqIDwgcmlnaHRBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXJyYXlbaysrXSA9IHJpZ2h0QXJyYXlbaisrXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhtZXJnZVNvcnQoWzEwMCwgMywgMiwgMSwgMTMsIDgsIDUsIDAsIDEsIDk4XSkpO1xyXG5cclxuLy8gQWx0ZXJuYXRpdmUgc29sdXRpb24uXHJcbmZ1bmN0aW9uIGFsdGVybmF0aXZlTWVyZ2VTb3J0KGFycmF5KSB7XHJcbiAgICBpZiAoYXJyYXkubGVuZ3RoIDwgMikgcmV0dXJuIGFycmF5OyAvLyBCYXNlIGNhc2VcclxuXHJcbiAgICBsZXQgbWlkZGxlUG9pbnQgPSBNYXRoLmZsb29yKGFycmF5Lmxlbmd0aCAvIDIpO1xyXG4gICAgbGV0IGxlZnRBcnJheSA9IGFycmF5LnNsaWNlKDAsIG1pZGRsZVBvaW50KTtcclxuICAgIGxldCByaWdodEFycmF5ID0gYXJyYXkuc2xpY2UobWlkZGxlUG9pbnQsIGFycmF5Lmxlbmd0aCk7XHJcblxyXG4gICAgcmV0dXJuIGFjdHVhbE1lcmdlcihhbHRlcm5hdGl2ZU1lcmdlU29ydChsZWZ0QXJyYXkpLCBhbHRlcm5hdGl2ZU1lcmdlU29ydChyaWdodEFycmF5KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFjdHVhbE1lcmdlcihsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBsZXQgaSA9IDAsIGogPSAwO1xyXG5cclxuICAgIC8vIE1lcmdlIHRoZSB0d28gc29ydGVkIGFycmF5c1xyXG4gICAgd2hpbGUgKGkgPCBsZWZ0Lmxlbmd0aCAmJiBqIDwgcmlnaHQubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGxlZnRbaV0gPD0gcmlnaHRbal0pIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobGVmdFtpKytdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChyaWdodFtqKytdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHJlbWFpbmluZyBlbGVtZW50cyBmcm9tIGxlZnQgYXJyYXlcclxuICAgIHdoaWxlIChpIDwgbGVmdC5sZW5ndGgpIHtcclxuICAgICAgICByZXN1bHQucHVzaChsZWZ0W2krK10pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCByZW1haW5pbmcgZWxlbWVudHMgZnJvbSByaWdodCBhcnJheVxyXG4gICAgd2hpbGUgKGogPCByaWdodC5sZW5ndGgpIHtcclxuICAgICAgICByZXN1bHQucHVzaChyaWdodFtqKytdKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhhbHRlcm5hdGl2ZU1lcmdlU29ydChbMTAwLCAzLCAyLCAxLCAxMywgOCwgNSwgMCwgMSwgOThdKSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ })()
;